import { useEffect, useState, useRef, useMemo, useCallback, memo } from 'react';
import { Loader2, Music2, AlignLeft, Clock } from 'lucide-react';
import { getLyrics, getCurrentLineIndex, getRandomNoLyricsMessage, noSyncedLyricsMessage, SyncedLine } from '../services/lyrics';
import { useLyricsStore } from '../lib/lyricsStore';

interface LyricsPanelProps {
  trackTitle: string;
  artistName: string;
  duration: number;
  currentTime: number;
  trackId?: string;
}

// Memoized individual lyric line to prevent re-renders
const LyricLine = memo(({ 
  line, 
  isCurrent, 
  isPast,
}: { 
  line: SyncedLine; 
  isCurrent: boolean; 
  isPast: boolean;
}) => (
  <div
    className={`text-center py-2 transition-all duration-300 ease-out ${
      isCurrent
        ? 'text-white text-xl sm:text-2xl md:text-3xl font-bold opacity-100 scale-105'
        : isPast
        ? 'text-white/30 text-sm sm:text-base opacity-50'
        : 'text-white/60 text-base sm:text-lg opacity-70'
    }`}
  >
    {line.text || 'â™ª'}
  </div>
));

LyricLine.displayName = 'LyricLine';

export function LyricsPanel({ trackTitle, artistName, duration, currentTime, trackId }: LyricsPanelProps) {
  const [loading, setLoading] = useState(false);
  const [viewMode, setViewMode] = useState<'synced' | 'plain'>('synced');
  const [noLyricsMessage] = useState(getRandomNoLyricsMessage());
  const [currentLineIndex, setCurrentLineIndex] = useState(-1);
  const containerRef = useRef<HTMLDivElement>(null);
  const lyricsContentRef = useRef<HTMLDivElement>(null);
  const [containerHeight, setContainerHeight] = useState(0);
  const [autoScroll, setAutoScroll] = useState(true);
  const userScrollTimeout = useRef<number | null>(null);
  
  // Zustand store for caching
  const { getCached, setLyrics, setCurrentTrack } = useLyricsStore();
  
  // Create a cache key from track info
  const cacheKey = useMemo(() => 
    trackId || `${trackTitle}-${artistName}`, 
    [trackId, trackTitle, artistName]
  );
  
  // Get cached data
  const cachedEntry = getCached(cacheKey);
  const lyrics = cachedEntry?.lyrics ?? null;
  const syncedLines = cachedEntry?.syncedLines ?? [];

  // Measure container height for centering calculation
  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;
    
    const updateHeight = () => {
      setContainerHeight(container.clientHeight);
    };
    
    updateHeight();
    const observer = new ResizeObserver(updateHeight);
    observer.observe(container);
    
    return () => observer.disconnect();
  }, []);

  // Fetch lyrics when track changes (only if not cached)
  useEffect(() => {
    let mounted = true;

    async function fetchLyrics() {
      if (!trackTitle || !artistName || !duration || duration <= 0) {
        return;
      }

      // Check cache first
      const cached = getCached(cacheKey);
      if (cached) {
        console.log('ðŸ“ Lyrics: Using cached lyrics for', trackTitle);
        setCurrentTrack(cacheKey);
        if (cached.syncedLines.length > 0) {
          setViewMode('synced');
        } else if (cached.lyrics?.plainLyrics) {
          setViewMode('plain');
        }
        setLoading(false);
        return;
      }

      console.log('ðŸ“ Lyrics: Fetching for', trackTitle, 'by', artistName);
      setLoading(true);
      setCurrentLineIndex(-1);

      const result = await getLyrics(trackTitle, artistName, duration);
      
      if (mounted) {
        setLyrics(cacheKey, result);
        setCurrentTrack(cacheKey);
        
        if (result?.syncedLyrics) {
          setViewMode('synced');
        } else if (result?.plainLyrics) {
          setViewMode('plain');
        }
        setLoading(false);
      }
    }

    fetchLyrics();

    return () => {
      mounted = false;
    };
  }, [cacheKey, trackTitle, artistName, duration, getCached, setLyrics, setCurrentTrack]);

  // Update current line based on playback time (memoized for performance)
  const updateCurrentLine = useCallback(() => {
    if (syncedLines.length > 0 && viewMode === 'synced') {
      const index = getCurrentLineIndex(syncedLines, currentTime);
      setCurrentLineIndex(index);
    }
  }, [syncedLines, currentTime, viewMode]);

  useEffect(() => {
    updateCurrentLine();
  }, [updateCurrentLine]);

  // Calculate the Y offset to keep current line at fixed position (40% from top)
  const translateY = useMemo(() => {
    if (!autoScroll || currentLineIndex < 0 || containerHeight === 0) return 0;
    
    // Average line height (text + padding)
    const lineHeight = 52;
    // Fixed position for current line (40% from top of container)
    const fixedPosition = containerHeight * 0.4;
    // Calculate offset to position current line at fixed position
    const currentLineOffset = currentLineIndex * lineHeight;
    
    return fixedPosition - currentLineOffset;
  }, [autoScroll, currentLineIndex, containerHeight]);

  // Handle user scroll - disable auto-scroll temporarily
  const handleUserScroll = useCallback(() => {
    if (!autoScroll) return; // Already disabled
    
    setAutoScroll(false);
    
    // Re-enable auto-scroll after 3 seconds of no interaction
    if (userScrollTimeout.current) {
      clearTimeout(userScrollTimeout.current);
    }
    
    userScrollTimeout.current = setTimeout(() => {
      setAutoScroll(true);
    }, 3000);
  }, [autoScroll]);

  // Loading state
  if (loading || (!cachedEntry && duration <= 0)) {
    return (
      <div className="flex flex-col items-center justify-center h-full py-20 text-white/60">
        <Loader2 size={32} className="animate-spin mb-4" />
        <p className="text-sm">Loading lyrics...</p>
      </div>
    );
  }

  // No lyrics found
  if (!lyrics || (lyrics.instrumental && !lyrics.plainLyrics && !lyrics.syncedLyrics)) {
    return (
      <div className="flex flex-col items-center justify-center h-full py-20 text-white/60 px-4 text-center">
        <Music2 size={48} className="mb-4 text-white/40" />
        <p className="text-base sm:text-lg font-medium mb-2">{noLyricsMessage}</p>
        <p className="text-xs sm:text-sm text-white/40">
          {lyrics?.instrumental ? 'This track is marked as instrumental' : 'Try another track!'}
        </p>
      </div>
    );
  }

  // Has plain lyrics but no synced
  if (!lyrics.syncedLyrics && lyrics.plainLyrics) {
    return (
      <div className="h-full overflow-y-auto px-4 sm:px-6 py-6">
        <div className="max-w-2xl mx-auto">
          <div className="flex items-center gap-2 mb-6 text-yellow-400/80 text-xs sm:text-sm">
            <AlignLeft size={16} />
            <p>{noSyncedLyricsMessage}</p>
          </div>
          <div className="whitespace-pre-wrap text-white/80 text-sm sm:text-base leading-relaxed">
            {lyrics.plainLyrics}
          </div>
        </div>
      </div>
    );
  }

  // Has synced lyrics - Spotify-style with sticky current line
  if (lyrics.syncedLyrics && syncedLines.length > 0) {
    return (
      <div className="h-full flex flex-col overflow-hidden">
        {/* View Mode Toggle */}
        {lyrics.plainLyrics && (
          <div className="flex items-center justify-center gap-2 py-3 border-b border-white/10 flex-shrink-0">
            <button
              onClick={() => setViewMode('synced')}
              className={`px-3 py-1.5 rounded-full text-xs sm:text-sm font-medium transition-colors flex items-center gap-1.5 ${
                viewMode === 'synced'
                  ? 'bg-white/20 text-white'
                  : 'text-white/50 hover:text-white/80'
              }`}
            >
              <Clock size={14} />
              SyncedScrollable container with optional auto-scroll */}
        <div 
          ref={containerRef}
          className="flex-1 relative overflow-y-auto overflow-x-hidden px-4 sm:px-6 overscroll-contain"
          onTouchStart={handleUserScroll}
          onWheel={handleUserScroll}
          style={{ 
            WebkitOverflowScrolling: 'touch',
            scrollBehavior: autoScroll ? 'smooth' : 'auto'
          }}
        >
          {viewMode === 'synced' ? (
            <>
              {/* Auto-scroll indicator */}
              {!autoScroll && (
                <div className="fixed top-20 left-1/2 -translate-x-1/2 z-20 px-3 py-1.5 bg-purple-500/90 text-white text-xs rounded-full shadow-lg backdrop-blur">
                  Auto-scroll paused
                </div>
              )}
              
              {/* Gradient overlay at top for fade effect */}
              <div className="sticky top-0 left-0 right-0 h-24 bg-gradient-to-b from-black/90 via-black/50 to-transparent z-10 pointer-events-none -mb-24" />
              
              {/* Lyrics container - user can scroll, auto-scroll positions when enabled */}
              <div 
                ref={lyricsContentRef}
                className="max-w-2xl mx-auto py-[40vh]"
                style={{ 
                  transform: autoScroll ? `translateY(${translateY}px)` : 'none',
                  transition: autoScroll ? 'transform 500ms ease-out' : 'none',
                  willChange: autoScroll ? 'transform' : 'auto'
                }}
              >
                {syncedLines.map((line, index) => (
                  <LyricLine
                    key={index}
                    line={line}
                    isCurrent={index === currentLineIndex}
                    isPast={index < currentLineIndex}
                  />
                ))}
              </div>
              
              {/* Gradient overlay at bottom for fade effect */}
              <div className="sticky bottom-0 left-0 right-0 h-24 bg-gradient-to-t from-black/90 via-black/50 to-transparent z-10 pointer-events-none -mt-24" /radient overlay at bottom for fade effect */}
              <div className="absolute bottom-0 left-0 right-0 h-32 bg-gradient-to-t from-black/90 via-black/50 to-transparent z-10 pointer-events-none" />
              
              {/* Lyrics container with smooth translateY animation */}
              <div 
                className="max-w-2xl mx-auto transition-transform duration-500 ease-out will-change-transform"
                style={{ transform: `translateY(${translateY}px)` }}
              >
                {syncedLines.map((line, index) => (
                  <LyricLine
                    key={index}
                    line={line}
                    isCurrent={index === currentLineIndex}
                    isPast={index < currentLineIndex}
                  />
                ))}
              </div>
            </>
          ) : (
            <div className="h-full overflow-y-auto py-6">
              <div className="max-w-2xl mx-auto whitespace-pre-wrap text-white/80 text-sm sm:text-base leading-relaxed">
                {lyrics.plainLyrics}
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }

  return null;
}
